{"ast":null,"code":"import _slicedToArray from \"/Users/sakhiahmad/Desktop/Uni/Front-end/pt-app/ptapp/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/sakhiahmad/Desktop/Uni/Front-end/pt-app/ptapp/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"/Users/sakhiahmad/Desktop/Uni/Front-end/pt-app/ptapp/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowGroupingNameSelector, gridRowTreeDepthsSelector, gridDataRowIdsSelector, gridRowsDataRowIdToIdLookupSelector, gridRowMaximumTreeDepthSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, isAutoGeneratedRow, GRID_ROOT_GROUP_ID, updateCacheWithNewRows, getTopLevelRowCount, getRowIdFromRowModel } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport var rowsStateInitializer = function rowsStateInitializer(state, props, apiRef) {\n  apiRef.current.caches.rows = createRowsInternalCache({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading,\n    rowCount: props.rowCount\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef: apiRef,\n      rowCountProp: props.rowCount,\n      loadingProp: props.loading,\n      previousTree: null,\n      previousTreeDepths: null\n    })\n  });\n};\nexport var useGridRows = function useGridRows(apiRef, props) {\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().\n      Object.freeze(props.rows);\n    } catch (error) {\n      // Sometimes, it's impossible to freeze, so we give up on it.\n    }\n  }\n  var logger = useGridLogger(apiRef, 'useGridRows');\n  var currentPage = useGridVisibleRows(apiRef, props);\n  var lastUpdateMs = React.useRef(Date.now());\n  var timeout = React.useRef(null);\n  var getRow = React.useCallback(function (id) {\n    var model = gridRowsLookupSelector(apiRef)[id];\n    if (model) {\n      return model;\n    }\n    var node = apiRef.current.getRowNode(id);\n    if (node && isAutoGeneratedRow(node)) {\n      // TODO rows v6: Is it the best approach ?\n      return {};\n    }\n    return null;\n  }, [apiRef]);\n  var lookup = React.useMemo(function () {\n    return currentPage.rows.reduce(function (acc, _ref2, index) {\n      var id = _ref2.id;\n      acc[id] = index;\n      return acc;\n    }, {});\n  }, [currentPage.rows]);\n  var throttledRowsChange = React.useCallback(function (_ref3) {\n    var cache = _ref3.cache,\n      throttle = _ref3.throttle;\n    var run = function run() {\n      timeout.current = null;\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(function (state) {\n        return _extends({}, state, {\n          rows: getRowsStateFromCache({\n            apiRef: apiRef,\n            rowCountProp: props.rowCount,\n            loadingProp: props.loading,\n            previousTree: gridRowTreeSelector(apiRef),\n            previousTreeDepths: gridRowTreeDepthsSelector(apiRef)\n          })\n        });\n      });\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      timeout.current = null;\n    }\n    apiRef.current.caches.rows = cache;\n    if (!throttle) {\n      run();\n      return;\n    }\n    var throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n    if (throttleRemainingTimeMs > 0) {\n      timeout.current = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n\n  /**\n   * API METHODS\n   */\n  var setRows = React.useCallback(function (rows) {\n    logger.debug(\"Updating all rows, new length \".concat(rows.length));\n    var cache = createRowsInternalCache({\n      rows: rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    });\n    var prevCache = apiRef.current.caches.rows;\n    cache.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;\n    throttledRowsChange({\n      cache: cache,\n      throttle: true\n    });\n  }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);\n  var updateRows = React.useCallback(function (updates) {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n    var cache = updateCacheWithNewRows({\n      updates: updates,\n      getRowId: props.getRowId,\n      previousCache: apiRef.current.caches.rows\n    });\n    throttledRowsChange({\n      cache: cache,\n      throttle: true\n    });\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  var getRowModels = React.useCallback(function () {\n    var dataRows = gridDataRowIdsSelector(apiRef);\n    var idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(dataRows.map(function (id) {\n      var _idRowsLookup$id;\n      return [id, (_idRowsLookup$id = idRowsLookup[id]) != null ? _idRowsLookup$id : {}];\n    }));\n  }, [apiRef]);\n  var getRowsCount = React.useCallback(function () {\n    return gridRowCountSelector(apiRef);\n  }, [apiRef]);\n  var getAllRowIds = React.useCallback(function () {\n    return gridDataRowIdsSelector(apiRef);\n  }, [apiRef]);\n  var getRowIndexRelativeToVisibleRows = React.useCallback(function (id) {\n    return lookup[id];\n  }, [lookup]);\n  var setRowChildrenExpansion = React.useCallback(function (id, isExpanded) {\n    var currentNode = apiRef.current.getRowNode(id);\n    if (!currentNode) {\n      throw new Error(\"MUI: No row with id #\".concat(id, \" found\"));\n    }\n    if (currentNode.type !== 'group') {\n      throw new Error('MUI: Only group nodes can be expanded or collapsed');\n    }\n    var newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n    apiRef.current.setState(function (state) {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, _defineProperty({}, id, newNode))\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  var getRowNode = React.useCallback(function (id) {\n    var _ref;\n    return (_ref = gridRowTreeSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  var getRowGroupChildren = React.useCallback(function (_ref4) {\n    var _ref4$skipAutoGenerat = _ref4.skipAutoGeneratedRows,\n      skipAutoGeneratedRows = _ref4$skipAutoGenerat === void 0 ? true : _ref4$skipAutoGenerat,\n      groupId = _ref4.groupId,\n      applySorting = _ref4.applySorting,\n      applyFiltering = _ref4.applyFiltering;\n    var tree = gridRowTreeSelector(apiRef);\n    var children;\n    if (applySorting) {\n      var groupNode = tree[groupId];\n      if (!groupNode) {\n        return [];\n      }\n      var sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      var startIndex = sortedRowIds.findIndex(function (id) {\n        return id === groupId;\n      }) + 1;\n      for (var index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        var id = sortedRowIds[index];\n        if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[id])) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n    if (applyFiltering) {\n      var filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(function (childId) {\n        return filteredRowsLookup[childId] !== false;\n      });\n    }\n    return children;\n  }, [apiRef]);\n  var setRowIndex = React.useCallback(function (rowId, targetIndex) {\n    var node = apiRef.current.getRowNode(rowId);\n    if (!node) {\n      throw new Error(\"MUI: No row with id #\".concat(rowId, \" found\"));\n    }\n    if (node.parent !== GRID_ROOT_GROUP_ID) {\n      throw new Error(\"MUI: The row reordering do not support reordering of grouped rows yet\");\n    }\n    if (node.type !== 'leaf') {\n      throw new Error(\"MUI: The row reordering do not support reordering of footer or grouping rows\");\n    }\n    apiRef.current.setState(function (state) {\n      var group = gridRowTreeSelector(state, apiRef.current.instanceId)[GRID_ROOT_GROUP_ID];\n      var allRows = group.children;\n      var oldIndex = allRows.findIndex(function (row) {\n        return row === rowId;\n      });\n      if (oldIndex === -1 || oldIndex === targetIndex) {\n        return state;\n      }\n      logger.debug(\"Moving row \".concat(rowId, \" to index \").concat(targetIndex));\n      var updatedRows = _toConsumableArray(allRows);\n      updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, _defineProperty({}, GRID_ROOT_GROUP_ID, _extends({}, group, {\n            children: updatedRows\n          })))\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, logger]);\n  var replaceRows = React.useCallback(function (firstRowToRender, newRows) {\n    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {\n      throw new Error([\"MUI: You can't replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n    if (newRows.length === 0) {\n      return;\n    }\n    var treeDepth = gridRowMaximumTreeDepthSelector(apiRef);\n    if (treeDepth > 1) {\n      throw new Error('`apiRef.current.unstable_replaceRows` is not compatible with tree data and row grouping');\n    }\n    var tree = _extends({}, gridRowTreeSelector(apiRef));\n    var dataRowIdToModelLookup = _extends({}, gridRowsLookupSelector(apiRef));\n    var dataRowIdToIdLookup = _extends({}, gridRowsDataRowIdToIdLookupSelector(apiRef));\n    var rootGroup = tree[GRID_ROOT_GROUP_ID];\n    var rootGroupChildren = _toConsumableArray(rootGroup.children);\n    for (var i = 0; i < newRows.length; i += 1) {\n      var rowModel = newRows[i];\n      var rowId = getRowIdFromRowModel(rowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');\n      var _rootGroupChildren$sp = rootGroupChildren.splice(firstRowToRender + i, 1, rowId),\n        _rootGroupChildren$sp2 = _slicedToArray(_rootGroupChildren$sp, 1),\n        replacedRowId = _rootGroupChildren$sp2[0];\n      delete dataRowIdToModelLookup[replacedRowId];\n      delete dataRowIdToIdLookup[replacedRowId];\n      delete tree[replacedRowId];\n      var rowTreeNodeConfig = {\n        id: rowId,\n        depth: 0,\n        parent: GRID_ROOT_GROUP_ID,\n        type: 'leaf',\n        groupingKey: null\n      };\n      dataRowIdToModelLookup[rowId] = rowModel;\n      dataRowIdToIdLookup[rowId] = rowId;\n      tree[rowId] = rowTreeNodeConfig;\n    }\n    tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroup, {\n      children: rootGroupChildren\n    });\n\n    // Removes potential remaining skeleton rows from the dataRowIds.\n    var dataRowIds = rootGroupChildren.filter(function (childId) {\n      return tree[childId].type === 'leaf';\n    });\n    apiRef.current.caches.rows.dataRowIdToModelLookup = dataRowIdToModelLookup;\n    apiRef.current.caches.rows.dataRowIdToIdLookup = dataRowIdToIdLookup;\n    apiRef.current.setState(function (state) {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          dataRowIdToModelLookup: dataRowIdToModelLookup,\n          dataRowIdToIdLookup: dataRowIdToIdLookup,\n          dataRowIds: dataRowIds,\n          tree: tree\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, props.signature, props.getRowId]);\n  var rowApi = {\n    getRow: getRow,\n    getRowModels: getRowModels,\n    getRowsCount: getRowsCount,\n    getAllRowIds: getAllRowIds,\n    setRows: setRows,\n    updateRows: updateRows,\n    getRowNode: getRowNode,\n    getRowIndexRelativeToVisibleRows: getRowIndexRelativeToVisibleRows,\n    unstable_replaceRows: replaceRows\n  };\n  var rowProApi = {\n    setRowIndex: setRowIndex,\n    setRowChildrenExpansion: setRowChildrenExpansion,\n    getRowGroupChildren: getRowGroupChildren\n  };\n\n  /**\n   * EVENTS\n   */\n  var groupRows = React.useCallback(function () {\n    logger.info(\"Row grouping pre-processing have changed, regenerating the row tree\");\n    var cache;\n    if (apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = _extends({}, apiRef.current.caches.rows, {\n        updates: {\n          type: 'full',\n          rows: gridDataRowIdsSelector(apiRef)\n        }\n      });\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      });\n    }\n    throttledRowsChange({\n      cache: cache,\n      throttle: false\n    });\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);\n  var handleStrategyProcessorChange = React.useCallback(function (methodName) {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  var handleStrategyActivityChange = React.useCallback(function () {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n\n  /**\n   * APPLIERS\n   */\n  var applyHydrateRowsProcessor = React.useCallback(function () {\n    apiRef.current.setState(function (state) {\n      var response = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n        tree: gridRowTreeSelector(state, apiRef.current.instanceId),\n        treeDepths: gridRowTreeDepthsSelector(state, apiRef.current.instanceId),\n        dataRowIds: gridDataRowIdsSelector(state, apiRef.current.instanceId),\n        dataRowIdToModelLookup: gridRowsLookupSelector(state, apiRef.current.instanceId),\n        dataRowIdToIdLookup: gridRowsDataRowIdToIdLookupSelector(state, apiRef.current.instanceId)\n      });\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, response, {\n          totalTopLevelRowCount: getTopLevelRowCount({\n            tree: response.tree,\n            rowCountProp: props.rowCount\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef, props.rowCount]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'public');\n  useGridApiMethod(apiRef, rowProApi, props.signature === GridSignature.DataGrid ? 'private' : 'public');\n\n  /**\n   * EFFECTS\n   */\n  React.useEffect(function () {\n    return function () {\n      if (timeout.current !== null) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []);\n\n  // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n  var isFirstRender = React.useRef(true);\n  React.useEffect(function () {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n    var areNewRowsAlreadyInState = apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows;\n    var isNewLoadingAlreadyInState = apiRef.current.caches.rows.loadingPropBeforePartialUpdates === props.loading;\n    var isNewRowCountAlreadyInState = apiRef.current.caches.rows.rowCountPropBeforePartialUpdates === props.rowCount;\n\n    // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(function (state) {\n          return _extends({}, state, {\n            rows: _extends({}, state.rows, {\n              loading: props.loading\n            })\n          });\n        });\n        apiRef.current.caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n      if (!isNewRowCountAlreadyInState) {\n        apiRef.current.setState(function (state) {\n          return _extends({}, state, {\n            rows: _extends({}, state.rows, {\n              totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),\n              totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)\n            })\n          });\n        });\n        apiRef.current.caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;\n        apiRef.current.forceUpdate();\n      }\n      return;\n    }\n    logger.debug(\"Updating all rows, new length \".concat(props.rows.length));\n    throttledRowsChange({\n      cache: createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      }),\n      throttle: false\n    });\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};","map":{"version":3,"names":["_extends","React","useGridApiMethod","useGridLogger","gridRowCountSelector","gridRowsLookupSelector","gridRowTreeSelector","gridRowGroupingNameSelector","gridRowTreeDepthsSelector","gridDataRowIdsSelector","gridRowsDataRowIdToIdLookupSelector","gridRowMaximumTreeDepthSelector","GridSignature","useGridApiEventHandler","useGridVisibleRows","gridSortedRowIdsSelector","gridFilteredRowsLookupSelector","getTreeNodeDescendants","createRowsInternalCache","getRowsStateFromCache","isAutoGeneratedRow","GRID_ROOT_GROUP_ID","updateCacheWithNewRows","getTopLevelRowCount","getRowIdFromRowModel","useGridRegisterPipeApplier","rowsStateInitializer","state","props","apiRef","current","caches","rows","getRowId","loading","rowCount","rowCountProp","loadingProp","previousTree","previousTreeDepths","useGridRows","process","env","NODE_ENV","Object","freeze","error","logger","currentPage","lastUpdateMs","useRef","Date","now","timeout","getRow","useCallback","id","model","node","getRowNode","lookup","useMemo","reduce","acc","_ref2","index","throttledRowsChange","_ref3","cache","throttle","run","setState","publishEvent","forceUpdate","clearTimeout","throttleRemainingTimeMs","throttleRowsMs","setTimeout","setRows","debug","concat","length","prevCache","rowsBeforePartialUpdates","updateRows","updates","signature","DataGrid","Error","join","previousCache","getRowModels","dataRows","idRowsLookup","Map","map","_idRowsLookup$id","getRowsCount","getAllRowIds","getRowIndexRelativeToVisibleRows","setRowChildrenExpansion","isExpanded","currentNode","type","newNode","childrenExpanded","tree","_defineProperty","_ref","getRowGroupChildren","_ref4","_ref4$skipAutoGenerat","skipAutoGeneratedRows","groupId","applySorting","applyFiltering","children","groupNode","sortedRowIds","startIndex","findIndex","depth","push","filteredRowsLookup","filter","childId","setRowIndex","rowId","targetIndex","parent","group","instanceId","allRows","oldIndex","row","updatedRows","_toConsumableArray","splice","replaceRows","firstRowToRender","newRows","treeDepth","dataRowIdToModelLookup","dataRowIdToIdLookup","rootGroup","rootGroupChildren","i","rowModel","_rootGroupChildren$sp","_rootGroupChildren$sp2","_slicedToArray","replacedRowId","rowTreeNodeConfig","groupingKey","dataRowIds","rowApi","unstable_replaceRows","rowProApi","groupRows","info","handleStrategyProcessorChange","methodName","handleStrategyActivityChange","getActiveStrategy","applyHydrateRowsProcessor","response","unstable_applyPipeProcessors","treeDepths","totalTopLevelRowCount","useEffect","isFirstRender","areNewRowsAlreadyInState","isNewLoadingAlreadyInState","loadingPropBeforePartialUpdates","isNewRowCountAlreadyInState","rowCountPropBeforePartialUpdates","totalRowCount","Math","max"],"sources":["/Users/sakhiahmad/Desktop/Uni/Front-end/pt-app/ptapp/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRows.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowGroupingNameSelector, gridRowTreeDepthsSelector, gridDataRowIdsSelector, gridRowsDataRowIdToIdLookupSelector, gridRowMaximumTreeDepthSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, isAutoGeneratedRow, GRID_ROOT_GROUP_ID, updateCacheWithNewRows, getTopLevelRowCount, getRowIdFromRowModel } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  apiRef.current.caches.rows = createRowsInternalCache({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading,\n    rowCount: props.rowCount\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef,\n      rowCountProp: props.rowCount,\n      loadingProp: props.loading,\n      previousTree: null,\n      previousTreeDepths: null\n    })\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().\n      Object.freeze(props.rows);\n    } catch (error) {\n      // Sometimes, it's impossible to freeze, so we give up on it.\n    }\n  }\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const timeout = React.useRef(null);\n  const getRow = React.useCallback(id => {\n    const model = gridRowsLookupSelector(apiRef)[id];\n    if (model) {\n      return model;\n    }\n    const node = apiRef.current.getRowNode(id);\n    if (node && isAutoGeneratedRow(node)) {\n      // TODO rows v6: Is it the best approach ?\n      return {};\n    }\n    return null;\n  }, [apiRef]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, {\n    id\n  }, index) => {\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback(({\n    cache,\n    throttle\n  }) => {\n    const run = () => {\n      timeout.current = null;\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache({\n          apiRef,\n          rowCountProp: props.rowCount,\n          loadingProp: props.loading,\n          previousTree: gridRowTreeSelector(apiRef),\n          previousTreeDepths: gridRowTreeDepthsSelector(apiRef)\n        })\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      timeout.current = null;\n    }\n    apiRef.current.caches.rows = cache;\n    if (!throttle) {\n      run();\n      return;\n    }\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n    if (throttleRemainingTimeMs > 0) {\n      timeout.current = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n\n  /**\n   * API METHODS\n   */\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    const cache = createRowsInternalCache({\n      rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    });\n    const prevCache = apiRef.current.caches.rows;\n    cache.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;\n    throttledRowsChange({\n      cache,\n      throttle: true\n    });\n  }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n    const cache = updateCacheWithNewRows({\n      updates,\n      getRowId: props.getRowId,\n      previousCache: apiRef.current.caches.rows\n    });\n    throttledRowsChange({\n      cache,\n      throttle: true\n    });\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const getRowModels = React.useCallback(() => {\n    const dataRows = gridDataRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(dataRows.map(id => {\n      var _idRowsLookup$id;\n      return [id, (_idRowsLookup$id = idRowsLookup[id]) != null ? _idRowsLookup$id : {}];\n    }));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridDataRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n    if (!currentNode) {\n      throw new Error(`MUI: No row with id #${id} found`);\n    }\n    if (currentNode.type !== 'group') {\n      throw new Error('MUI: Only group nodes can be expanded or collapsed');\n    }\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _ref;\n    return (_ref = gridRowTreeSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  const getRowGroupChildren = React.useCallback(({\n    skipAutoGeneratedRows = true,\n    groupId,\n    applySorting,\n    applyFiltering\n  }) => {\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n    if (applySorting) {\n      const groupNode = tree[groupId];\n      if (!groupNode) {\n        return [];\n      }\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n        if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[id])) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const node = apiRef.current.getRowNode(rowId);\n    if (!node) {\n      throw new Error(`MUI: No row with id #${rowId} found`);\n    }\n    if (node.parent !== GRID_ROOT_GROUP_ID) {\n      throw new Error(`MUI: The row reordering do not support reordering of grouped rows yet`);\n    }\n    if (node.type !== 'leaf') {\n      throw new Error(`MUI: The row reordering do not support reordering of footer or grouping rows`);\n    }\n    apiRef.current.setState(state => {\n      const group = gridRowTreeSelector(state, apiRef.current.instanceId)[GRID_ROOT_GROUP_ID];\n      const allRows = group.children;\n      const oldIndex = allRows.findIndex(row => row === rowId);\n      if (oldIndex === -1 || oldIndex === targetIndex) {\n        return state;\n      }\n      logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n      const updatedRows = [...allRows];\n      updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [GRID_ROOT_GROUP_ID]: _extends({}, group, {\n              children: updatedRows\n            })\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, logger]);\n  const replaceRows = React.useCallback((firstRowToRender, newRows) => {\n    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {\n      throw new Error([\"MUI: You can't replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n    if (newRows.length === 0) {\n      return;\n    }\n    const treeDepth = gridRowMaximumTreeDepthSelector(apiRef);\n    if (treeDepth > 1) {\n      throw new Error('`apiRef.current.unstable_replaceRows` is not compatible with tree data and row grouping');\n    }\n    const tree = _extends({}, gridRowTreeSelector(apiRef));\n    const dataRowIdToModelLookup = _extends({}, gridRowsLookupSelector(apiRef));\n    const dataRowIdToIdLookup = _extends({}, gridRowsDataRowIdToIdLookupSelector(apiRef));\n    const rootGroup = tree[GRID_ROOT_GROUP_ID];\n    const rootGroupChildren = [...rootGroup.children];\n    for (let i = 0; i < newRows.length; i += 1) {\n      const rowModel = newRows[i];\n      const rowId = getRowIdFromRowModel(rowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');\n      const [replacedRowId] = rootGroupChildren.splice(firstRowToRender + i, 1, rowId);\n      delete dataRowIdToModelLookup[replacedRowId];\n      delete dataRowIdToIdLookup[replacedRowId];\n      delete tree[replacedRowId];\n      const rowTreeNodeConfig = {\n        id: rowId,\n        depth: 0,\n        parent: GRID_ROOT_GROUP_ID,\n        type: 'leaf',\n        groupingKey: null\n      };\n      dataRowIdToModelLookup[rowId] = rowModel;\n      dataRowIdToIdLookup[rowId] = rowId;\n      tree[rowId] = rowTreeNodeConfig;\n    }\n    tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroup, {\n      children: rootGroupChildren\n    });\n\n    // Removes potential remaining skeleton rows from the dataRowIds.\n    const dataRowIds = rootGroupChildren.filter(childId => tree[childId].type === 'leaf');\n    apiRef.current.caches.rows.dataRowIdToModelLookup = dataRowIdToModelLookup;\n    apiRef.current.caches.rows.dataRowIdToIdLookup = dataRowIdToIdLookup;\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        dataRowIdToModelLookup,\n        dataRowIdToIdLookup,\n        dataRowIds,\n        tree\n      })\n    }));\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, props.signature, props.getRowId]);\n  const rowApi = {\n    getRow,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    updateRows,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    unstable_replaceRows: replaceRows\n  };\n  const rowProApi = {\n    setRowIndex,\n    setRowChildrenExpansion,\n    getRowGroupChildren\n  };\n\n  /**\n   * EVENTS\n   */\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let cache;\n    if (apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = _extends({}, apiRef.current.caches.rows, {\n        updates: {\n          type: 'full',\n          rows: gridDataRowIdsSelector(apiRef)\n        }\n      });\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      });\n    }\n    throttledRowsChange({\n      cache,\n      throttle: false\n    });\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n\n  /**\n   * APPLIERS\n   */\n  const applyHydrateRowsProcessor = React.useCallback(() => {\n    apiRef.current.setState(state => {\n      const response = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n        tree: gridRowTreeSelector(state, apiRef.current.instanceId),\n        treeDepths: gridRowTreeDepthsSelector(state, apiRef.current.instanceId),\n        dataRowIds: gridDataRowIdsSelector(state, apiRef.current.instanceId),\n        dataRowIdToModelLookup: gridRowsLookupSelector(state, apiRef.current.instanceId),\n        dataRowIdToIdLookup: gridRowsDataRowIdToIdLookupSelector(state, apiRef.current.instanceId)\n      });\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, response, {\n          totalTopLevelRowCount: getTopLevelRowCount({\n            tree: response.tree,\n            rowCountProp: props.rowCount\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef, props.rowCount]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'public');\n  useGridApiMethod(apiRef, rowProApi, props.signature === GridSignature.DataGrid ? 'private' : 'public');\n\n  /**\n   * EFFECTS\n   */\n  React.useEffect(() => {\n    return () => {\n      if (timeout.current !== null) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []);\n\n  // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n    const areNewRowsAlreadyInState = apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows;\n    const isNewLoadingAlreadyInState = apiRef.current.caches.rows.loadingPropBeforePartialUpdates === props.loading;\n    const isNewRowCountAlreadyInState = apiRef.current.caches.rows.rowCountPropBeforePartialUpdates === props.rowCount;\n\n    // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            loading: props.loading\n          })\n        }));\n        apiRef.current.caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n      if (!isNewRowCountAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),\n            totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)\n          })\n        }));\n        apiRef.current.caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;\n        apiRef.current.forceUpdate();\n      }\n      return;\n    }\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange({\n      cache: createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      }),\n      throttle: false\n    });\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}